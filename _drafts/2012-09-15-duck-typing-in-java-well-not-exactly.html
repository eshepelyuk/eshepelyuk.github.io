---
layout: post
title: Duck typing in Java ? Well, not exactly
date: '2012-09-15T12:59:00.002+03:00'
author: Evgeny Shepelyuk
tags:
- java
- groovy
- duck typing
modified_time: '2012-09-15T13:09:05.816+03:00'
blogger_id: tag:blogger.com,1999:blog-4998424779235998349.post-269431959756296376
blogger_orig_url: http://eshepelyuk.blogspot.com/2012/09/duck-typing-in-java-well-not-exactly.html
---

<span style="font-size: large;">What is it all about ?</span><br /><span style="font-size: large;"><br /></span>According to Wikipedia duck typing is<br /><blockquote class="tr_bq">style of dynamic typing in which an object's methods and properties determine the valid semantics, rather than its inheritance from a particular class or implementation of a specific interface</blockquote>In simplier words<br /><blockquote class="tr_bq">When I see a bird that walks like a duck and swims like a duck and quacks like a duck, I call that bird a duck</blockquote>In languages with dynamic typing this feature allows creating function that are not checking type of passed object but instead rely on existence of particular methods/properties within it and throws runtime exception when those properties not found. For instance, in groovy we could have method for printing info about some entity<br /><br /><pre class="brush: groovy">def printEntity = {entity -&gt;<br /> println "id: ${entity.id}, name: ${entity.name}" <br />}</pre>Let's say we have following class<br /><pre class="brush: groovy">class Entity {<br /> Long id<br /> String name<br />}<br /></pre>So we can invoke our function<br /><pre class="brush: plain">printEntity(new Entity(id: 10L, name: 'MyName1'))<br />id: 10, name: MyName1<br /></pre>But the same time we could pass map as argument<br /><pre class="brush: plain">printEntity(['id':10L, 'name':'MyName2'])<br />id: 10, name: MyName2<br /></pre>Using some metaprogramming magic we could write even following<br /><pre class="brush: groovy">class Ghost {<br /> def propertyMissing(String name) {<br />  if (name == 'id') {<br />   return -1L<br />  } else if (name == 'name') {<br />   return "StubName"<br />  }<br /> }<br />}<br /></pre>And we will be still able to call our function<br /><pre class="brush: plain">printEntity(new Ghost())<br />id: -1, name: StubName<br /></pre><br /><span style="font-size: large;">Welcome to the real world&nbsp;</span><br /><span style="font-size: large;"><br /></span>Fortunately this concept can be used not only for languages with dynamic typing but for ones with more strict typing model, as Java. Wikipedia has good <a href="http://en.wikipedia.org/wiki/Duck_typing#In_Java" target="_blank">example</a> of duck typing implementation in Java <span style="font-family: inherit;">using </span><span style="font-family: &quot;Courier New&quot;, Courier, monospace;">Proxy</span> class.<br /><br />Well, you say, what is the practical usage of this except feeling oneself the wisest guru :) Let me show some real life task that was solved in Java using duck typing technique.<br /><br />From the beginning I had simple report generator that queries DB of products and outputs id and name of certain entity. But then customer says: "I'd like to also have link to the entity detail page at our site. Beautiful, SEO friendly link. Could you do it to me". "Sure ", I said. After digging our codebase I've discovered cool function <span style="font-family: &quot;Courier New&quot;, Courier, monospace;">generateSeoUrl() </span>that does the job. The function takes one argument of type <span style="font-family: &quot;Courier New&quot;, Courier, monospace;">Entity</span>, which is interface. So my intention was to observe implementations of <span style="font-family: &quot;Courier New&quot;, Courier, monospace;">Entity</span> and try to use one of them for the report generation. How surprised was I after discovering that all of them are part of some self made <span style="font-family: &quot;Courier New&quot;, Courier, monospace;">ORM</span> tool and their constructors accept query DB to get the entire information about product.<br /><br />So if I were using <span style="font-family: &quot;Courier New&quot;, Courier, monospace;">Entity</span> implementations I had to deal with one extra query per row of my report and this is unacceptable since report was comprised of huge number of rows. So I decided to try other approach and implement <span style="font-family: &quot;Courier New&quot;, Courier, monospace;">Entity</span> interface, overriding methods that are used by <span style="font-family: &quot;Courier New&quot;, Courier, monospace;">generateSeoUrl()</span>. I clicked my IDE shortcut and got surprised again. <span style="font-family: &quot;Courier New&quot;, Courier, monospace;">Entity</span> had about 50 (!!!) methods. Well, I already knew that only<span style="font-family: &quot;Courier New&quot;, Courier, monospace;"> getEntityId()</span> and <span style="font-family: &quot;Courier New&quot;, Courier, monospace;">getName()</span> are used by <span style="font-family: &quot;Courier New&quot;, Courier, monospace;">generateSeoUrl() </span>function, but then again, having new class with 50 empty methods just to override 2 of them doing useful action seemed not good idea for me.<br /><br />Thus I've decided stop trying coding and start to think :) Extend some of the <span style="font-family: &quot;Courier New&quot;, Courier, monospace;">Entity</span> implementation to prevent querying DB or copy + paste<span style="font-family: &quot;Courier New&quot;, Courier, monospace;"> generateSeoUrl()</span> and adopt it for my needs were the options but still it was not beautiful. Especially when I reminded duck typing. I said to myself, we have a function that takes instance of <span style="font-family: &quot;Courier New&quot;, Courier, monospace;">Entity</span> but only uses two method of this interface, so to complete my task I need something that looks like <span style="font-family: &quot;Courier New&quot;, Courier, monospace;">Entity</span> and able to handle <span style="font-family: &quot;Courier New&quot;, Courier, monospace;">getEntityId()</span> and <span style="font-family: &quot;Courier New&quot;, Courier, monospace;">getName() </span><span style="font-family: inherit;">methods.</span><br /><br />Since <span style="font-family: &quot;Courier New&quot;, Courier, monospace;">entityId</span> and <span style="font-family: &quot;Courier New&quot;, Courier, monospace;">name</span> were already present in data used for generating my report I could reuse them in my new class to stub data for <span style="font-family: &quot;Courier New&quot;, Courier, monospace;">getEntityId() </span>and <span style="font-family: &quot;Courier New&quot;, Courier, monospace;">getName()</span>. To achieve duck typing we need to create <span style="font-family: &quot;Courier New&quot;, Courier, monospace;">Proxy</span> that also implements <span style="font-family: &quot;Courier New&quot;, Courier, monospace;">InvocationHandler</span> interface and static method to retrieve instance of <span style="font-family: &quot;Courier New&quot;, Courier, monospace;">Proxy</span>. Final code of my class looks like<br /><br /><pre class="brush:java">public class ReportEntitySupport implements InvocationHandler {<br /><br />    public static Entity newInstance(Long entityId, String name) {<br />        return (Entity) Proxy.newProxyInstance(<br />                Product.class.getClassLoader(),<br />                Product.class.getInterfaces(),<br />                new ReportEntitySupport(entityId, name)<br />        );<br />    }<br /><br />    private final String name;<br />    private final Long entityId;<br /><br />    private ReportEntitySupport(Long entityId, String name) {<br />        this.name = name;<br />        this.entityId = entityId;<br />    }<br /><br />    @Override<br />    public Object invoke(Object proxy, Method method, Object[] args) throws Throwable {<br />        if (method.getName().equals("getName")) {<br />            return this.name;<br />        } else if (method.getName().equals("getEntityId")) {<br />            return this.entityId;<br />        }<br />        return null;<br />    }<br />}<br /></pre><br />So how to use it ?<br /><br />Inside my report generator class while iterating over ResultSet I'm using following<br /><pre class="brush:java">Long entityId;<br />String name;<br />....<br />Entity entity = ReportEntitySupport.newIntance(entityId, name);<br />String seoUrl = generateSeoUrl(entity);<br />....</pre><br /><span style="font-size: large;">P.S.</span><span style="font-size: large;"><br /></span><br /><span style="font-size: small;">This post just illustrates that some uncommon for Java language concepts could be successfully applied for completing real life tasks improving your programming skills and making your code more beautiful.</span><span style="font-size: large;"><br /></span>