---
tags:
- java
- nashorn
- tdd
- javascript
- jasmine
- groovy
- spock
excerpt: |
  `JavaScript` is not only browser powered client-side or `NodeJS` powered server-side code.
  Many `JVM` based projects are also using it as internal scripting language.
  Testing this sort of functionality is neither straightforward nor standard.
  In this post I intend to show approach for testing `JavaScript` code in server-side JVM environment
  using well-known tools like `Jasmine`, `Spock` and `Nashorn`.
---
:imagesdir: /images/drafts
= Testing JVM server-side JavaScript with Jasmine, Spock and Nashorn

`JavaScript` is not only browser powered client-side or `NodeJS` powered server-side code.
Many `JVM` based projects are also using it as internal scripting language.
Testing this sort of functionality is neither straightforward nor standard.
In this post I intend to show approach for testing `JavaScript` code in server-side JVM environment
using well-known tools like `Jasmine`, `Spock` and `Nashorn`.

Using JavaScript as scripting engine inside JVM application has significant difference comparing to client-side coding.
There's no industrial standard tools nowadays for testing embedded JavaScript. 

Regarding existing approaches found in WWW I'd like to outline following disadvantages::
* lack of integration with build and _Continuous Integration_ tools (Maven, Gradle, Jenkins, etc.)
* insufficient cooperation with IDEs
** no possibility to run single suite or test from IDE
** unable to view test execution reports from IDE
* tight coupling to browser environment
* no possibility of using customized `JavaScript` executor

As far as I've seen most of the projects test their business scripts by calling JS engine runner, 
passing script under test to it and doing assertion by inspecting side-effects after script execution.

Those kind of approaches usually have similar drawbacks::
* hard to stub or mock something, usually ends up hacking on `prototype`
* hard to organize tests into suites and report test execution errors
* need too much orchestration
* custom test suite code for each project
* not leveraging robust JavaScript testing tools and frameworks

So, driven by the need for comfortable embedded JavaScript testing in JVM projects I've createdthis sample setup.
To fulfil our goals next tools will be used.

* `Jasmine` is one of the most known TDD/BDD tools for JavaScript
* `Spock` is great testing framework for JVM powered by Junit and Groovy
* `Nashorn` is modern scripting engine introduced in JDK8

== Customized JavaScript runner (Nashorn based)

There's no need to conform standards in non-browser JS environments, so usually
developers extend scripting engine with custom functions, built-in variables etc.
It is extremely important to use exactly the same runner both for production and testing purposes.

Let's consider we have such customized runner, accepting script name and map of predefined variables as parameters 
and returning resulting value of the executed script.

[source,java]
.JavaScriptRunner.java
----
public class JavaScriptRunner {
  public static Object run(String script, Map<String, Object> params) throws Exception {
    ScriptEngineManager factory = new ScriptEngineManager();
    ScriptEngine engine = factory.getEngineByName("nashorn");
    engine.getBindings(ScriptContext.ENGINE_SCOPE).putAll(params);
    return engine.eval(new InputStreamReader(JavaScriptRunner.class.getResourceAsStream(script))); <1>
  }
}
----
<1> script source is searched in classpath.
 
== Jasmine setup

To start using `Jasmine` framework we need

* https://github.com/pivotal/jasmine/releases/download/v2.1.2/jasmine-standalone-2.1.2.zip[download Jasmine^] 
and unpack it to `/jasmine/jasmine-2.1.2` folder in project resources directory
* custom bootstrap script, since `Jasmine` doesn't support JVM based platforms

[source, javascript]
.jasmine-bootstrap.js
----
var loadFromClassPath = function(path) { <1>
  load(Java.type("ua.eshepelyuk.blog.nashorn.Jasmine2Specification").class.getResource(path).toExternalForm());
};

var window = this;

loadFromClassPath("/jasmine/jasmine-2.1.2/jasmine.js");
loadFromClassPath("/jasmine/jasmine-html-stub.js"); <2>
loadFromClassPath("/jasmine/jasmine-2.1.2/boot.js");
load({script: __jasmineSpec__, name: __jasmineSpecName__}); <3>

onload(); <4>

jsApiReporter.specs(); <5>
----
<1> helper function resolving script path from classpath location.
<2> `Nashorn` specific code adjusting `Jasmine` for non-browser environments. Not a part of `Jasmine` distribution.
<3> loading test suite source code, see next section for details.
<4> faking browser `load` event, that should trigger test suite exection.
<5> this value will be returned as script result.

== Transform Jasmine report into Spock tests

Get Jasmine report from executor and create fake tests with Spock data provider.

Having JS executor and bootstrap script for `Jasmine` we could create single `Spock	` or `JUnit` test to check if all results are successful. But this gonna be a nightmare to understand which exact test had failed and what is the reason of failure.

What we really like to have is display

[source,groovy]
.Jasmine2Specification.groovy
----
abstract class Jasmine2Specification extends Specification {
  @Shared def jasmineResults

  def setupSpec() {
    def scriptParams = [
        "__jasmineSpec__"    : getMetaClass().getMetaProperty("SPEC").getProperty(null), <1>
        "__jasmineSpecName__": "${this.class.simpleName}.groovy"
    ]
    jasmineResults = JavaScriptRunner.run("/jasmine/jasmine2-bootstrap.js", scriptParams)
  }

  def isPassed(def specRes) {specRes.status == "passed" || specRes.status == "pending"}

  def specErrorMsg(def specResult) {
    specResult.failedExpectations
	.collect {it.value}.collect {it.stack}.join("\n\n\n")
  }

  @Unroll def '#specName'() {
    expect:
      assert isPassed(item), specErrorMsg(item) <2>
    where:
      item << jasmineResults.collect { it.value }
      specName = (item.status != "pending" ? item.fullName : "IGNORED: $item.fullName") <3>
  }
}
----
<1> exposing source code of `Jasmine` suite as __jasmineSpec__ variable, accessible to JS executor.
<2> for each suite result we assert either it is succeeded, displaying `Jasmine` originated error message on failure.
<3> additional data provider variable to highlight ignored tests.

== Complete example

Let's create test suite for simple JavaScript function.

[source, javascript]
.mathUtils.js
----
var add = function add(a, b) {
  return a + b;
};
----

Using base class from previous step we could create `Spock` suite containing JavaScript tests.
To demonstrate all the possibilities of our solution we will create successful, failed and ignored test.

[source,groovy]
.MathUtilsTest.groovy
----
class MathUtilsTest extends Jasmine2Specification {
    static def SPEC = """ <1>
loadFromClassPath("/js/mathUtils.js"); <2>
describe("suite 1", function() {
  it("should pass", function() {
    expect(add(1, 2)).toBe(3);
  });
  it("should fail", function() {
    expect(add(1, 2)).toBe(3);
    expect(add(1, 2)).toBe(0);
  });
  xit("should be ignored", function() {
    expect(add(1, 2)).toBe(3);
  });
})
"""
}
----
<1> actual code of `Jasmine` suite is represented as a `String` variable.
<2> loading module under test using function inherited from `jasmine-bootstrap.js`.

.Test results from IntelliJ IDEAx
image::1.png[Test results from IntelliJ IDEA]

== IntelliJ Idea language injection

Although this micro framework should work in all the IDEs the most handy usage of it will be within *IntelliJ IDEA*
thanks to its https://www.jetbrains.com/idea/help/using-language-injections.html[language injection^].
The feature allows to embed arbitrary language into file created in different programming language. 
So we could have JavaScript code block embedded into `Spock` specification written in Groovy.

.Language injection
image::2.png[Language injection]

== Pros and cons of the solution

Advantages::
* usage of industry standard testing tools for both languages
* seamless integration with build tools and continous integration tools
* ability to run single suite from IDE
* run single test from the particular suite, thanks to http://pivotallabs.com/new-key-features-jasmine-2-1/[focused feature of Jasmine^]

Disadvantages::
* no clean way of detecting particular line of source code in case of test exception

For the sample project I've used latest `Nashorn` engine from JDK.
But in fact there's no limitation on this. The same approach was succesfully applied for projects using older `Rhino` engine.
And then again, `Jasmine` is just my personal preference. With additional work code could be adjusted to leverage `Mocha`, `QUnit` and so on.

NOTE: Full project's code is available at https://github.com/eshepelyuk/CodeForBlog/tree/master/TestMeIfYouCanNashornSpock[GitHub^]
