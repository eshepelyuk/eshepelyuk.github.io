---
layout: post
title: Test Me If You Can (#1)
date: '2013-06-28T20:37:00.001+03:00'
author: Evgeny Shepelyuk
tags:
- java
- tdd
- spring
- mockito
modified_time: '2013-06-28T21:29:08.890+03:00'
blogger_id: tag:blogger.com,1999:blog-4998424779235998349.post-5605644346272834774
blogger_orig_url: http://eshepelyuk.blogspot.com/2013/06/test-me-if-you-can-1.html
---

<span style="font-size: large;">The purpose of this post series</span><br /><span style="font-size: large;"><br /></span>During my career I often observed people who claim that they are not writing tests because "can't cover" integration between components. Well, I believe most of such people just don't know some simply techniques or don't have time to dig them out because of stress at their work place. The lack of such knowledge results into neglecting of integration tests and thus worse software, more bugs and disappointed customer.<br /><br />So I've decided to share some practices collected during last couple of years that are revealing mystery surrounding integration testing. The series will be concentrated around Spring framework, that I'm most familiar with. Let's start :)<br /><br /><span style="font-size: large;">Better integration test for Spring based projects</span><br /><br />Tools: <span style="font-family: &quot;Courier New&quot;, Courier, monospace;">Spring, </span><span style="font-family: &quot;Courier New&quot;, Courier, monospace;">JUnit, </span><span style="font-family: &quot;Courier New&quot;, Courier, monospace;">Mockito</span><br /><ul></ul>Imagine the situation with Spring based project that's integrating an external service, e.g. some bank web services. Issues related to writing test cases and running them within CI for such code are usually the same<br /><ul><li>price per transaction, each time test executed - customer pays</li><li>tests requests can be interpreted as suspicious traffic, account blocked - tests failures</li><li>when using non production environments for tests, it can be unstable - again, tests failures</li></ul>Usually such problems can be solved by mocking such external service while testing single class that using it, but when it comes to the need for test larger business flow - you need to run your tests again many components and made them managed by your container - Spring. Luckily Spring has great <a href="http://static.springsource.org/spring/docs/3.2.x/spring-framework-reference/html/testing.html" target="_blank">test framework</a> &nbsp;but one needs to mock external services herself. First intention could be creating mocks in <span style="font-family: &quot;Courier New&quot;, Courier, monospace;">setUp</span> section of your test and override Spring beans, but think more about it<br /><blockquote class="tr_bq"><i>You're overriding behavior of container for your test, so there's no guarantee it will work the same way for real services.</i></blockquote>We have not to mock our external services and then re-inject them into corresponding beans, <b><i>we have to make Spring inject mocks in place of particular beans</i></b>, necessary for our goals. Let's illustrate this with code.<br /><br />My sample project comprises <span style="font-family: &quot;Courier New&quot;, Courier, monospace;">BankService </span>representing external service and <span style="font-family: &quot;Courier New&quot;, Courier, monospace;">UserBalanceService</span> - our business entity working with <span style="font-family: &quot;Courier New&quot;, Courier, monospace;">BankService</span>. <span style="font-family: &quot;Courier New&quot;, Courier, monospace;">UserBalanceService</span> is quite simple wrapper - just making conversion from <span style="font-family: &quot;Courier New&quot;, Courier, monospace;">String</span> to <span style="font-family: &quot;Courier New&quot;, Courier, monospace;">Double</span>.<br /><pre class="brush: java" title="BankService.java">public interface BankService {<br />    String getBalanceByEmail(String email);<br />}<br /></pre><pre class="brush: java" title="BankServiceImpl.java">public class BankServiceImpl implements BankService {<br />    @Override<br />    public String getBalanceByEmail(String email) {<br />        throw new UnsupportedOperationException("Operation failed due to external exception");<br />    }<br />}<br /></pre><pre class="brush: java" title="UserBalanceService.java">interface UserBalanceService {<br />    Double getAccountBalance(String email);<br />}<br /></pre><pre class="brush: java" title="UserBalanceServiceImpl.java">public class UserBalanceServiceImpl implements UserBalanceService {<br />    @Autowired<br />    private BankService bankService;<br />    @Override<br />    public Double getAccountBalance(String email) {<br />        return Double.valueOf(bankService.getBalanceByEmail(email));<br />    }<br />}<br /></pre>And Spring dependency XML configuration wiring everything together<br /><pre class="brush: xml" title="applicationContext.xml">&lt;?xml version="1.0" encoding="UTF-8"?&gt;<br />&lt;beans xmlns="http://www.springframework.org/schema/beans"<br />       xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"<br />       xsi:schemaLocation="http://www.springframework.org/schema/beans<br />       http://www.springframework.org/schema/beans/spring-beans.xsd"&gt;<br />    &lt;bean id="bankService" class="ua.eshepelyuk.blog.springtest.springockito.BankServiceImpl"/&gt;<br />    &lt;bean id="userBalanceService" class="ua.eshepelyuk.blog.springtest.springockito.UserBalanceServiceImpl"/&gt;<br />&lt;/beans&gt;<br /></pre>Our test will look like<br /><pre class="brush: java" title="UserBalanceServiceImplTest.java">@RunWith(SpringJUnit4ClassRunner.class)<br />@ContextConfiguration(locations = "classpath:/springtest/springockito/applicationContext.xml")<br />public class UserBalanceServiceImplProfileTest {<br />    @Autowired<br />    private UserBalanceService userBalanceService;<br />    @Autowired<br />    private BankService bankService;<br />    @Test<br />    public void shouldReturnMockedBalance() {<br />        Double balance = userBalanceService.getAccountBalance("user@bank.com");<br />        assertEquals(balance, Double.valueOf(123.45D));<br />    }<br />}<br /></pre>As expected after test run we will have <span style="font-family: &quot;Courier New&quot;, Courier, monospace;">UnsupportedOperationException</span>. Our intention is to replace BankService with mock and tune its behaviour. It's possible to use <span style="font-family: &quot;Courier New&quot;, Courier, monospace;">Mockito</span> directly as factory bean but there's better alternative - <a href="https://bitbucket.org/kubek2k/springockito/wiki/Home" target="_blank">Springockito</a> framework. Please take a look before proceed :)<br /><br />The remaining question is how to instruct spring to inject mocks, Prior to version 3.1 there were no alternatives except creating brand new XML configuration for using it in test. But with introduction of <a href="http://blog.springsource.com/2011/02/11/spring-framework-3-1-m1-released" target="_blank"><span style="font-family: inherit;">Bean Definition Profiles</span></a> &nbsp;we now able to create more elegant solution for this, although we still need separate XML for test purposes. This is how resulting test XML configuration will look like<br /><pre class="brush: xml">&lt;?xml version="1.0" encoding="UTF-8"?&gt;<br />&lt;beans xmlns="http://www.springframework.org/schema/beans"<br />       xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"<br />       xmlns:mockito="http://www.mockito.org/spring/mockito"<br />       xsi:schemaLocation="http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd<br />       http://www.mockito.org/spring/mockito https://bitbucket.org/kubek2k/springockito/raw/tip/springockito/src/main/resources/spring/mockito.xsd"&gt;<br />    &lt;import resource="classpath:/springtest/springockito/applicationContext.xml"/&gt;<br />    &lt;beans profile="springTest"&gt;<br />        &lt;mockito:mock id="bankService" class="ua.eshepelyuk.blog.springtest.springockito.BankService"/&gt;<br />    &lt;/beans&gt;<br />&lt;/beans&gt;</pre><br />And the test modified accordingly.<br /><pre class="brush: java; highlight: [2,3,11]">@RunWith(SpringJUnit4ClassRunner.class)<br />@ContextConfiguration(locations = "classpath:/springtest/springockito/testApplicationContext.xml")<br />@ActiveProfiles(profiles = {"springTest"})<br />public class UserBalanceServiceImplProfileTest {<br />    @Autowired<br />    private UserBalanceService userBalanceService;<br />    @Autowired<br />    private BankService bankService;<br />    @Before<br />    public void setUp() throws Exception {<br />        Mockito.when(bankService.getBalanceByEmail("user@bank.com")).thenReturn(String.valueOf(123.45D));<br />    }<br />    @Test<br />    public void shouldReturnMockedBalance() {<br />        Double balance = userBalanceService.getAccountBalance("user@bank.com");<br />        assertEquals(balance, Double.valueOf(123.45D));<br />    }<br />}<br /></pre>You may notice appearance of <span style="font-family: &quot;Courier New&quot;, Courier, monospace;">setUp </span>method for setting up the mock behavior and new <span style="font-family: &quot;Courier New&quot;, Courier, monospace;">@Profile </span>annotation. The annotation activates our profile <span style="font-family: &quot;Courier New&quot;, Courier, monospace;">springTest</span><span style="font-family: inherit;">,</span> so bean mocked with <span style="font-family: &quot;Courier New&quot;, Courier, monospace;">Springockito </span>will be injected where necessary. When run this we will have test passed since spring injected mock that we've configured and not the external service.<br /><br /><span style="font-size: large;">Don't stop on the way to perfectness</span><br /><br />It could be the end of the story be we could still go deeper on the problem. <span style="font-family: &quot;Courier New&quot;, Courier, monospace;">Springockito </span>creator has another framework <span style="font-family: &quot;Courier New&quot;, Courier, monospace;"><a href="https://bitbucket.org/kubek2k/springockito/wiki/springockito-annotations" target="_blank">springockito-annotations</a></span> . The framework allows mock injection using annotation within test classes. Please skim read it before proceed :)<br /><br />After some modification code of our test will look this way.<br /><pre class="brush: java; highlight: [2,8]">@RunWith(SpringJUnit4ClassRunner.class)<br />@ContextConfiguration(loader = SpringockitoContextLoader.class, <br />    locations = "classpath:/springtest/springockito/applicationContext.xml")<br />public class UserBalanceServiceImplAnnotationTest {<br />    @Autowired<br />    private UserBalanceService userBalanceService;<br />    @Autowired<br />    @ReplaceWithMock<br />    private BankService bankService;<br />    @Before<br />    public void setUp() throws Exception {<br />        Mockito.when(bankService.getBalanceByEmail("user@bank.com")).thenReturn(String.valueOf(valueOf(123.45D)));<br />    }<br />    @Test<br />    public void shouldReturnMockedBalance() {<br />        Double balance = userBalanceService.getAccountBalance("user@bank.com");<br />        assertEquals(balance, valueOf(123.45D));<br />    }<br />}</pre><br />Please note that no new XML configuration required. We're using production XML config and just override single bean using <span style="font-family: &quot;Courier New&quot;, Courier, monospace;">@ReplaceWithMock&nbsp;</span><span style="font-family: inherit;">annotation. Later we can customize the mock in </span><span style="font-family: &quot;Courier New&quot;, Courier, monospace;">setUp</span><span style="font-family: inherit;"> method.</span><br /><br /><span style="font-size: large;">P.S.</span><br /><br /><span style="font-family: &quot;Courier New&quot;, Courier, monospace;">Springockito-annotations</span> project has one great advantage - it provides test code only based dependency override mechanism. Neither additional XML, nor production code modifications for test purposes. Unlike <span style="font-family: &quot;Courier New&quot;, Courier, monospace;">springockito-annotations</span> the XML based &nbsp;approach makes creation of test specific XML mandatory always. So I strongly recommend iusing <span style="font-family: &quot;Courier New&quot;, Courier, monospace;">Springockito-annotations</span> project for your integration tests, so they won't affect your production code design and won't produce additional artifacts - i.e. configuration files.<br /><br /><span style="font-size: large;">P.P.S.</span><br />Writing integration tests for Spring is easy ! Project can be found on <a href="https://github.com/eshepelyuk/CodeForBlog/tree/master/TestMeIfYouCan1" target="_blank">my GitHub</a>